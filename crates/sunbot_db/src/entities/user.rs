//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.1

use sea_orm::entity::prelude::*;
use sea_orm::{ActiveValue::Set};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "user")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub user_id: i64,
    pub username: String,
    pub display_name: Option<String>,
    pub temperature: f32,
    pub keywords: Json,
    pub interaction_count: i32,
    pub last_interaction: Option<DateTimeUtc>,
    pub relationship_notes: Option<String>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

// Helper type for keywords JSON field
pub type Keywords = Vec<String>;

impl Model {
    /// Create a new user with default relationship state
    pub fn new(user_id: i64, username: String, display_name: Option<String>) -> ActiveModel {
        ActiveModel {
            user_id: Set(user_id),
            username: Set(username),
            display_name: Set(display_name),
            temperature: Set(0.0),
            keywords: Set(Json::from(Keywords::new())),
            interaction_count: Set(0),
            last_interaction: Set(None),
            relationship_notes: Set(None),
            created_at: Set(chrono::Utc::now()),
            updated_at: Set(chrono::Utc::now()),
        }
    }

    /// Update the user's relationship state after an interaction
    pub fn update_interaction(
        &self, 
        temperature_delta: Option<f32>, 
        new_keywords: Option<Vec<String>>,
        notes: Option<String>
    ) -> ActiveModel {
        let mut keywords: Keywords = match serde_json::from_value(self.keywords.clone()) {
            Ok(k) => k,
            Err(_) => Vec::new(),
        };
        
        if let Some(new_keys) = new_keywords {
            for keyword in new_keys {
                if !keywords.contains(&keyword) {
                    keywords.push(keyword);
                }
            }
            // Keep only the last 20 keywords to avoid unbounded growth
            if keywords.len() > 20 {
                let keywords_len = keywords.len();
                keywords = keywords.into_iter().skip(keywords_len - 20).collect();
            }
        }

        let new_temperature = if let Some(delta) = temperature_delta {
            (self.temperature + delta).clamp(-1.0, 1.0)
        } else {
            self.temperature
        };

        ActiveModel {
            user_id: Set(self.user_id),
            temperature: Set(new_temperature),
            keywords: Set(Json::from(keywords)),
            interaction_count: Set(self.interaction_count + 1),
            last_interaction: Set(Some(chrono::Utc::now())),
            relationship_notes: Set(notes.or(self.relationship_notes.clone())),
            updated_at: Set(chrono::Utc::now()),
            ..Default::default()
        }
    }

    /// Get a formatted description of the user's relationship state for AI context
    pub fn get_relationship_context(&self) -> String {
        let mut context = Vec::new();
        
        // Temperature description
        let temp_desc = match self.temperature {
            t if t >= 0.7 => "very friendly and warm",
            t if t >= 0.3 => "friendly",
            t if t >= 0.1 => "neutral-positive",
            t if t >= -0.1 => "neutral",
            t if t >= -0.3 => "slightly distant", 
            t if t >= -0.7 => "unfriendly",
            _ => "hostile"
        };
        context.push(format!("Relationship status: {}", temp_desc));

        // Keywords/interests
        if let Ok(keywords) = serde_json::from_value::<Keywords>(self.keywords.clone()) {
            if !keywords.is_empty() {
                context.push(format!("User interests: {}", keywords.join(", ")));
            }
        }

        // Interaction history
        context.push(format!("Total interactions: {}", self.interaction_count));

        if let Some(ref notes) = self.relationship_notes {
            context.push(format!("Notes: {}", notes));
        }

        context.join(". ")
    }
}